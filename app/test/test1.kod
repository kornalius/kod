#"globals"

#MY_CONST 2 * (3 + 4)

puts(true, false, PI, ceil(PI_2))

let x
let y = 10
let i = 10
let j = 20
let z = [10, MY_CONST]
let s = { :k 10 :f => (x) return x end }

x = 100
y += 20

puts(i j x z[1] MY_CONST, y)

if 30 > 20
  puts("greater")
  // i = 23
  if (i > 20)
    puts("a")
  else
    puts("b")
  end
else if (20 > (3 + 4) * i)
  puts("cool")
else
  puts("lesser")

end

let t = 20
while (i < 20)
  let t = 10
  puts(t)
  i = i + 1
end
puts(t)

let f => (a, b, c)
  puts(a / b + c)
end

f(10, 20, 30)

puts(s.k, s.f(2), s.f(103))

for i = 1 to s.k
  puts(i)
end

class myClass1

  constructor => (a)

    let in_fn => (a)
      puts(a)
    end

    @x = a
    @y = a + 10
    puts(@)
    in_fn(100)
  end

end

class myClass2 : myClass1

  constructor => (a)
    super(a)
  end

end

let c = new myClass2(10)

puts(m_x)

// console.info("Should not work!")

// puts(Array)
// puts(alert)
// puts(console)
// puts(window)
